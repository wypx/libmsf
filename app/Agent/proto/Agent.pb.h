// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Agent.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Agent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Agent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Agent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Agent_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Agent_2eproto;
namespace Agent {
class AgentBhs;
struct AgentBhsDefaultTypeInternal;
extern AgentBhsDefaultTypeInternal _AgentBhs_default_instance_;
class AgentPdu;
struct AgentPduDefaultTypeInternal;
extern AgentPduDefaultTypeInternal _AgentPdu_default_instance_;
class Chap;
struct ChapDefaultTypeInternal;
extern ChapDefaultTypeInternal _Chap_default_instance_;
class HeartBeatReponse;
struct HeartBeatReponseDefaultTypeInternal;
extern HeartBeatReponseDefaultTypeInternal _HeartBeatReponse_default_instance_;
class HeartBeatRequest;
struct HeartBeatRequestDefaultTypeInternal;
extern HeartBeatRequestDefaultTypeInternal _HeartBeatRequest_default_instance_;
class LoginReponse;
struct LoginReponseDefaultTypeInternal;
extern LoginReponseDefaultTypeInternal _LoginReponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
}  // namespace Agent
PROTOBUF_NAMESPACE_OPEN
template<> ::Agent::AgentBhs* Arena::CreateMaybeMessage<::Agent::AgentBhs>(Arena*);
template<> ::Agent::AgentPdu* Arena::CreateMaybeMessage<::Agent::AgentPdu>(Arena*);
template<> ::Agent::Chap* Arena::CreateMaybeMessage<::Agent::Chap>(Arena*);
template<> ::Agent::HeartBeatReponse* Arena::CreateMaybeMessage<::Agent::HeartBeatReponse>(Arena*);
template<> ::Agent::HeartBeatRequest* Arena::CreateMaybeMessage<::Agent::HeartBeatRequest>(Arena*);
template<> ::Agent::LoginReponse* Arena::CreateMaybeMessage<::Agent::LoginReponse>(Arena*);
template<> ::Agent::LoginRequest* Arena::CreateMaybeMessage<::Agent::LoginRequest>(Arena*);
template<> ::Agent::NodeInfo* Arena::CreateMaybeMessage<::Agent::NodeInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Agent {

enum Errno : int {
  ERR_EXEC_SUCESS = 0,
  ERR_EXEC_FAILURE = 1,
  ERR_LOGIN_SUCESS = 2,
  ERR_LOGIN_FAILURE = 3,
  ERR_LOGIN_UNAUTH = 4,
  ERR_PEER_OFFLINE = 5,
  ERR_SEND_TIMEROUT = 6,
  ERR_RECV_TIMEROUT = 7,
  ERR_CANNOT_IN_LOOP = 8,
  ERR_AGENT_NOT_START = 9,
  ERR_ENCODE_FAILURE = 10,
  ERR_DECODE_FAILURE = 11,
  ERR_UNKNOWN_MAGIC = 12,
  ERR_UNKNOWN_COMMAND = 13,
  ERR_REPEAT_REGISTERED = 14,
  ERR_SERVER_INNER_ERR = 15,
  Errno_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Errno_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Errno_IsValid(int value);
constexpr Errno Errno_MIN = ERR_EXEC_SUCESS;
constexpr Errno Errno_MAX = ERR_SERVER_INNER_ERR;
constexpr int Errno_ARRAYSIZE = Errno_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Errno_descriptor();
template<typename T>
inline const std::string& Errno_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Errno>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Errno_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Errno_descriptor(), enum_t_value);
}
inline bool Errno_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Errno* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Errno>(
    Errno_descriptor(), name, value);
}
enum Command : int {
  CMD_REQ_NODE_REGISTER = 0,
  CMD_REQ_NODE_UNREGISTER = 1,
  CMD_REQ_NODE_HEARTBEAT = 2,
  CMD_REQ_NODE_STATUS_REPORT = 3,
  CMD_REQ_NODE_LOGGER_COLLECT = 4,
  CMD_REQ_NODE_LOGGER_LEVEL = 5,
  CMD_REQ_NODE_QUERY = 6,
  CMD_REQ_NODE_NOTIFY = 7,
  CMD_REQ_NODE_LEADER_ELECTION = 8,
  CMD_REQ_STORAGE_READ = 256,
  CMD_REQ_STORAGE_WRITE = 257,
  CMD_REQ_MOBILE_READ = 258,
  CMD_REQ_MOBILE_WRITE = 259,
  Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Command_IsValid(int value);
constexpr Command Command_MIN = CMD_REQ_NODE_REGISTER;
constexpr Command Command_MAX = CMD_REQ_MOBILE_WRITE;
constexpr int Command_ARRAYSIZE = Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_descriptor();
template<typename T>
inline const std::string& Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Command_descriptor(), enum_t_value);
}
inline bool Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
enum AppId : int {
  APP_ONESELF = 0,
  APP_AGENT = 1,
  APP_GUARD = 2,
  APP_MOBILE = 3,
  APP_DLNA = 4,
  APP_UPNP = 5,
  APP_DDNS = 6,
  AppId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AppId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AppId_IsValid(int value);
constexpr AppId AppId_MIN = APP_ONESELF;
constexpr AppId AppId_MAX = APP_DDNS;
constexpr int AppId_ARRAYSIZE = AppId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppId_descriptor();
template<typename T>
inline const std::string& AppId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppId_descriptor(), enum_t_value);
}
inline bool AppId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppId>(
    AppId_descriptor(), name, value);
}
enum PackType : int {
  PACK_BINNARY = 0,
  PACK_JSON = 1,
  PACK_PROTOBUF = 2,
  PACK_BUTT = 3,
  PackType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PackType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PackType_IsValid(int value);
constexpr PackType PackType_MIN = PACK_BINNARY;
constexpr PackType PackType_MAX = PACK_BUTT;
constexpr int PackType_ARRAYSIZE = PackType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PackType_descriptor();
template<typename T>
inline const std::string& PackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PackType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PackType_descriptor(), enum_t_value);
}
inline bool PackType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PackType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PackType>(
    PackType_descriptor(), name, value);
}
enum Opcode : int {
  OP_REQ = 0,
  OP_RSP = 1,
  Opcode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Opcode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Opcode_IsValid(int value);
constexpr Opcode Opcode_MIN = OP_REQ;
constexpr Opcode Opcode_MAX = OP_RSP;
constexpr int Opcode_ARRAYSIZE = Opcode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Opcode_descriptor();
template<typename T>
inline const std::string& Opcode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Opcode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Opcode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Opcode_descriptor(), enum_t_value);
}
inline bool Opcode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Opcode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Opcode>(
    Opcode_descriptor(), name, value);
}
enum NetType : int {
  NET_ETH = 0,
  NET_WLAN = 1,
  NET_MOBILE = 2,
  NetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NetType_IsValid(int value);
constexpr NetType NetType_MIN = NET_ETH;
constexpr NetType NetType_MAX = NET_MOBILE;
constexpr int NetType_ARRAYSIZE = NetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetType_descriptor();
template<typename T>
inline const std::string& NetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetType_descriptor(), enum_t_value);
}
inline bool NetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetType>(
    NetType_descriptor(), name, value);
}
enum NodeStatus : int {
  STATUS_ONLINE = 0,
  STATUS_OFFLINE = 1,
  STATUS_IDLE = 2,
  STATUS_BUSY = 3,
  NodeStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NodeStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NodeStatus_IsValid(int value);
constexpr NodeStatus NodeStatus_MIN = STATUS_ONLINE;
constexpr NodeStatus NodeStatus_MAX = STATUS_BUSY;
constexpr int NodeStatus_ARRAYSIZE = NodeStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeStatus_descriptor();
template<typename T>
inline const std::string& NodeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeStatus_descriptor(), enum_t_value);
}
inline bool NodeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeStatus>(
    NodeStatus_descriptor(), name, value);
}
// ===================================================================

class AgentBhs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.AgentBhs) */ {
 public:
  inline AgentBhs() : AgentBhs(nullptr) {}
  ~AgentBhs() override;
  explicit constexpr AgentBhs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentBhs(const AgentBhs& from);
  AgentBhs(AgentBhs&& from) noexcept
    : AgentBhs() {
    *this = ::std::move(from);
  }

  inline AgentBhs& operator=(const AgentBhs& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentBhs& operator=(AgentBhs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentBhs& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentBhs* internal_default_instance() {
    return reinterpret_cast<const AgentBhs*>(
               &_AgentBhs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AgentBhs& a, AgentBhs& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentBhs* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentBhs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentBhs* New() const final {
    return new AgentBhs();
  }

  AgentBhs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentBhs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentBhs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AgentBhs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentBhs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.AgentBhs";
  }
  protected:
  explicit AgentBhs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerifyFieldNumber = 1,
    kRouterFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // fixed64 verify = 1;
  void clear_verify();
  ::PROTOBUF_NAMESPACE_ID::uint64 verify() const;
  void set_verify(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_verify() const;
  void _internal_set_verify(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // fixed64 router = 2;
  void clear_router();
  ::PROTOBUF_NAMESPACE_ID::uint64 router() const;
  void set_router(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_router() const;
  void _internal_set_router(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // fixed64 command = 3;
  void clear_command();
  ::PROTOBUF_NAMESPACE_ID::uint64 command() const;
  void set_command(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_command() const;
  void _internal_set_command(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:Agent.AgentBhs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 verify_;
  ::PROTOBUF_NAMESPACE_ID::uint64 router_;
  ::PROTOBUF_NAMESPACE_ID::uint64 command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// -------------------------------------------------------------------

class Chap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.Chap) */ {
 public:
  inline Chap() : Chap(nullptr) {}
  ~Chap() override;
  explicit constexpr Chap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chap(const Chap& from);
  Chap(Chap&& from) noexcept
    : Chap() {
    *this = ::std::move(from);
  }

  inline Chap& operator=(const Chap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chap& operator=(Chap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chap* internal_default_instance() {
    return reinterpret_cast<const Chap*>(
               &_Chap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Chap& a, Chap& b) {
    a.Swap(&b);
  }
  inline void Swap(Chap* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Chap* New() const final {
    return new Chap();
  }

  Chap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Chap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Chap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.Chap";
  }
  protected:
  explicit Chap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 3,
    kPhaseFieldNumber = 1,
    kAlgFieldNumber = 2,
  };
  // bytes hash = 3;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // uint32 phase = 1;
  void clear_phase();
  ::PROTOBUF_NAMESPACE_ID::uint32 phase() const;
  void set_phase(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_phase() const;
  void _internal_set_phase(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 alg = 2;
  void clear_alg();
  ::PROTOBUF_NAMESPACE_ID::uint32 alg() const;
  void set_alg(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_alg() const;
  void _internal_set_alg(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Agent.Chap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 phase_;
  ::PROTOBUF_NAMESPACE_ID::uint32 alg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit constexpr LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return new LoginRequest();
  }

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTokenFieldNumber = 5,
    kChapFieldNumber = 3,
    kNetFieldNumber = 4,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes token = 5;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_MUST_USE_RESULT std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // .Agent.Chap chap = 3;
  bool has_chap() const;
  private:
  bool _internal_has_chap() const;
  public:
  void clear_chap();
  const ::Agent::Chap& chap() const;
  PROTOBUF_MUST_USE_RESULT ::Agent::Chap* release_chap();
  ::Agent::Chap* mutable_chap();
  void set_allocated_chap(::Agent::Chap* chap);
  private:
  const ::Agent::Chap& _internal_chap() const;
  ::Agent::Chap* _internal_mutable_chap();
  public:
  void unsafe_arena_set_allocated_chap(
      ::Agent::Chap* chap);
  ::Agent::Chap* unsafe_arena_release_chap();

  // .Agent.NetType net = 4;
  void clear_net();
  ::Agent::NetType net() const;
  void set_net(::Agent::NetType value);
  private:
  ::Agent::NetType _internal_net() const;
  void _internal_set_net(::Agent::NetType value);
  public:

  // @@protoc_insertion_point(class_scope:Agent.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::Agent::Chap* chap_;
  int net_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// -------------------------------------------------------------------

class LoginReponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.LoginReponse) */ {
 public:
  inline LoginReponse() : LoginReponse(nullptr) {}
  ~LoginReponse() override;
  explicit constexpr LoginReponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReponse(const LoginReponse& from);
  LoginReponse(LoginReponse&& from) noexcept
    : LoginReponse() {
    *this = ::std::move(from);
  }

  inline LoginReponse& operator=(const LoginReponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReponse& operator=(LoginReponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReponse* internal_default_instance() {
    return reinterpret_cast<const LoginReponse*>(
               &_LoginReponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginReponse& a, LoginReponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginReponse* New() const final {
    return new LoginReponse();
  }

  LoginReponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginReponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.LoginReponse";
  }
  protected:
  explicit LoginReponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kTtlFieldNumber = 2,
  };
  // bytes msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // fixed32 ttl = 2;
  void clear_ttl();
  ::PROTOBUF_NAMESPACE_ID::uint32 ttl() const;
  void set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ttl() const;
  void _internal_set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Agent.LoginReponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ttl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() override;
  explicit constexpr NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return new NodeInfo();
  }

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NodeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCidFieldNumber = 2,
    kStatusFieldNumber = 3,
    kNetFieldNumber = 4,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Agent.AppId cid = 2;
  void clear_cid();
  ::Agent::AppId cid() const;
  void set_cid(::Agent::AppId value);
  private:
  ::Agent::AppId _internal_cid() const;
  void _internal_set_cid(::Agent::AppId value);
  public:

  // .Agent.NodeStatus status = 3;
  void clear_status();
  ::Agent::NodeStatus status() const;
  void set_status(::Agent::NodeStatus value);
  private:
  ::Agent::NodeStatus _internal_status() const;
  void _internal_set_status(::Agent::NodeStatus value);
  public:

  // .Agent.NetType net = 4;
  void clear_net();
  ::Agent::NetType net() const;
  void set_net(::Agent::NetType value);
  private:
  ::Agent::NetType _internal_net() const;
  void _internal_set_net(::Agent::NetType value);
  public:

  // @@protoc_insertion_point(class_scope:Agent.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int cid_;
  int status_;
  int net_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.HeartBeatRequest) */ {
 public:
  inline HeartBeatRequest() : HeartBeatRequest(nullptr) {}
  ~HeartBeatRequest() override;
  explicit constexpr HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatRequest(const HeartBeatRequest& from);
  HeartBeatRequest(HeartBeatRequest&& from) noexcept
    : HeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatRequest& operator=(HeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRequest*>(
               &_HeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartBeatRequest& a, HeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartBeatRequest* New() const final {
    return new HeartBeatRequest();
  }

  HeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartBeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.HeartBeatRequest";
  }
  protected:
  explicit HeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Agent.AppId cid = 2;
  void clear_cid();
  ::Agent::AppId cid() const;
  void set_cid(::Agent::AppId value);
  private:
  ::Agent::AppId _internal_cid() const;
  void _internal_set_cid(::Agent::AppId value);
  public:

  // @@protoc_insertion_point(class_scope:Agent.HeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int cid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// -------------------------------------------------------------------

class HeartBeatReponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.HeartBeatReponse) */ {
 public:
  inline HeartBeatReponse() : HeartBeatReponse(nullptr) {}
  ~HeartBeatReponse() override;
  explicit constexpr HeartBeatReponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeatReponse(const HeartBeatReponse& from);
  HeartBeatReponse(HeartBeatReponse&& from) noexcept
    : HeartBeatReponse() {
    *this = ::std::move(from);
  }

  inline HeartBeatReponse& operator=(const HeartBeatReponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeatReponse& operator=(HeartBeatReponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeatReponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeatReponse* internal_default_instance() {
    return reinterpret_cast<const HeartBeatReponse*>(
               &_HeartBeatReponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HeartBeatReponse& a, HeartBeatReponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeatReponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeatReponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeartBeatReponse* New() const final {
    return new HeartBeatReponse();
  }

  HeartBeatReponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeartBeatReponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeatReponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartBeatReponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatReponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.HeartBeatReponse";
  }
  protected:
  explicit HeartBeatReponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .Agent.NodeInfo nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::Agent::NodeInfo* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Agent::NodeInfo >*
      mutable_nodes();
  private:
  const ::Agent::NodeInfo& _internal_nodes(int index) const;
  ::Agent::NodeInfo* _internal_add_nodes();
  public:
  const ::Agent::NodeInfo& nodes(int index) const;
  ::Agent::NodeInfo* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Agent::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:Agent.HeartBeatReponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Agent::NodeInfo > nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// -------------------------------------------------------------------

class AgentPdu final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Agent.AgentPdu) */ {
 public:
  inline AgentPdu() : AgentPdu(nullptr) {}
  ~AgentPdu() override;
  explicit constexpr AgentPdu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentPdu(const AgentPdu& from);
  AgentPdu(AgentPdu&& from) noexcept
    : AgentPdu() {
    *this = ::std::move(from);
  }

  inline AgentPdu& operator=(const AgentPdu& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentPdu& operator=(AgentPdu&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentPdu& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentPdu* internal_default_instance() {
    return reinterpret_cast<const AgentPdu*>(
               &_AgentPdu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AgentPdu& a, AgentPdu& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentPdu* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentPdu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentPdu* New() const final {
    return new AgentPdu();
  }

  AgentPdu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentPdu>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentPdu& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AgentPdu& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentPdu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Agent.AgentPdu";
  }
  protected:
  explicit AgentPdu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBhsFieldNumber = 1,
    kReqLoginFieldNumber = 2,
    kRspLoginFieldNumber = 3,
    kReqHbFieldNumber = 4,
    kRspHbFieldNumber = 5,
  };
  // .Agent.AgentBhs bhs = 1;
  bool has_bhs() const;
  private:
  bool _internal_has_bhs() const;
  public:
  void clear_bhs();
  const ::Agent::AgentBhs& bhs() const;
  PROTOBUF_MUST_USE_RESULT ::Agent::AgentBhs* release_bhs();
  ::Agent::AgentBhs* mutable_bhs();
  void set_allocated_bhs(::Agent::AgentBhs* bhs);
  private:
  const ::Agent::AgentBhs& _internal_bhs() const;
  ::Agent::AgentBhs* _internal_mutable_bhs();
  public:
  void unsafe_arena_set_allocated_bhs(
      ::Agent::AgentBhs* bhs);
  ::Agent::AgentBhs* unsafe_arena_release_bhs();

  // .Agent.LoginRequest reqLogin = 2;
  bool has_reqlogin() const;
  private:
  bool _internal_has_reqlogin() const;
  public:
  void clear_reqlogin();
  const ::Agent::LoginRequest& reqlogin() const;
  PROTOBUF_MUST_USE_RESULT ::Agent::LoginRequest* release_reqlogin();
  ::Agent::LoginRequest* mutable_reqlogin();
  void set_allocated_reqlogin(::Agent::LoginRequest* reqlogin);
  private:
  const ::Agent::LoginRequest& _internal_reqlogin() const;
  ::Agent::LoginRequest* _internal_mutable_reqlogin();
  public:
  void unsafe_arena_set_allocated_reqlogin(
      ::Agent::LoginRequest* reqlogin);
  ::Agent::LoginRequest* unsafe_arena_release_reqlogin();

  // .Agent.LoginReponse rspLogin = 3;
  bool has_rsplogin() const;
  private:
  bool _internal_has_rsplogin() const;
  public:
  void clear_rsplogin();
  const ::Agent::LoginReponse& rsplogin() const;
  PROTOBUF_MUST_USE_RESULT ::Agent::LoginReponse* release_rsplogin();
  ::Agent::LoginReponse* mutable_rsplogin();
  void set_allocated_rsplogin(::Agent::LoginReponse* rsplogin);
  private:
  const ::Agent::LoginReponse& _internal_rsplogin() const;
  ::Agent::LoginReponse* _internal_mutable_rsplogin();
  public:
  void unsafe_arena_set_allocated_rsplogin(
      ::Agent::LoginReponse* rsplogin);
  ::Agent::LoginReponse* unsafe_arena_release_rsplogin();

  // .Agent.HeartBeatRequest reqHb = 4;
  bool has_reqhb() const;
  private:
  bool _internal_has_reqhb() const;
  public:
  void clear_reqhb();
  const ::Agent::HeartBeatRequest& reqhb() const;
  PROTOBUF_MUST_USE_RESULT ::Agent::HeartBeatRequest* release_reqhb();
  ::Agent::HeartBeatRequest* mutable_reqhb();
  void set_allocated_reqhb(::Agent::HeartBeatRequest* reqhb);
  private:
  const ::Agent::HeartBeatRequest& _internal_reqhb() const;
  ::Agent::HeartBeatRequest* _internal_mutable_reqhb();
  public:
  void unsafe_arena_set_allocated_reqhb(
      ::Agent::HeartBeatRequest* reqhb);
  ::Agent::HeartBeatRequest* unsafe_arena_release_reqhb();

  // .Agent.HeartBeatReponse rspHb = 5;
  bool has_rsphb() const;
  private:
  bool _internal_has_rsphb() const;
  public:
  void clear_rsphb();
  const ::Agent::HeartBeatReponse& rsphb() const;
  PROTOBUF_MUST_USE_RESULT ::Agent::HeartBeatReponse* release_rsphb();
  ::Agent::HeartBeatReponse* mutable_rsphb();
  void set_allocated_rsphb(::Agent::HeartBeatReponse* rsphb);
  private:
  const ::Agent::HeartBeatReponse& _internal_rsphb() const;
  ::Agent::HeartBeatReponse* _internal_mutable_rsphb();
  public:
  void unsafe_arena_set_allocated_rsphb(
      ::Agent::HeartBeatReponse* rsphb);
  ::Agent::HeartBeatReponse* unsafe_arena_release_rsphb();

  // @@protoc_insertion_point(class_scope:Agent.AgentPdu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Agent::AgentBhs* bhs_;
  ::Agent::LoginRequest* reqlogin_;
  ::Agent::LoginReponse* rsplogin_;
  ::Agent::HeartBeatRequest* reqhb_;
  ::Agent::HeartBeatReponse* rsphb_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Agent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AgentBhs

// fixed64 verify = 1;
inline void AgentBhs::clear_verify() {
  verify_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AgentBhs::_internal_verify() const {
  return verify_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AgentBhs::verify() const {
  // @@protoc_insertion_point(field_get:Agent.AgentBhs.verify)
  return _internal_verify();
}
inline void AgentBhs::_internal_set_verify(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  verify_ = value;
}
inline void AgentBhs::set_verify(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_verify(value);
  // @@protoc_insertion_point(field_set:Agent.AgentBhs.verify)
}

// fixed64 router = 2;
inline void AgentBhs::clear_router() {
  router_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AgentBhs::_internal_router() const {
  return router_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AgentBhs::router() const {
  // @@protoc_insertion_point(field_get:Agent.AgentBhs.router)
  return _internal_router();
}
inline void AgentBhs::_internal_set_router(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  router_ = value;
}
inline void AgentBhs::set_router(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_router(value);
  // @@protoc_insertion_point(field_set:Agent.AgentBhs.router)
}

// fixed64 command = 3;
inline void AgentBhs::clear_command() {
  command_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AgentBhs::_internal_command() const {
  return command_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AgentBhs::command() const {
  // @@protoc_insertion_point(field_get:Agent.AgentBhs.command)
  return _internal_command();
}
inline void AgentBhs::_internal_set_command(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  command_ = value;
}
inline void AgentBhs::set_command(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:Agent.AgentBhs.command)
}

// -------------------------------------------------------------------

// Chap

// uint32 phase = 1;
inline void Chap::clear_phase() {
  phase_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Chap::_internal_phase() const {
  return phase_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Chap::phase() const {
  // @@protoc_insertion_point(field_get:Agent.Chap.phase)
  return _internal_phase();
}
inline void Chap::_internal_set_phase(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  phase_ = value;
}
inline void Chap::set_phase(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:Agent.Chap.phase)
}

// uint32 alg = 2;
inline void Chap::clear_alg() {
  alg_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Chap::_internal_alg() const {
  return alg_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Chap::alg() const {
  // @@protoc_insertion_point(field_get:Agent.Chap.alg)
  return _internal_alg();
}
inline void Chap::_internal_set_alg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  alg_ = value;
}
inline void Chap::set_alg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_alg(value);
  // @@protoc_insertion_point(field_set:Agent.Chap.alg)
}

// bytes hash = 3;
inline void Chap::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& Chap::hash() const {
  // @@protoc_insertion_point(field_get:Agent.Chap.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chap::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Agent.Chap.hash)
}
inline std::string* Chap::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:Agent.Chap.hash)
  return _s;
}
inline const std::string& Chap::_internal_hash() const {
  return hash_.Get();
}
inline void Chap::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Chap::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Chap::release_hash() {
  // @@protoc_insertion_point(field_release:Agent.Chap.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Chap::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Agent.Chap.hash)
}

// -------------------------------------------------------------------

// LoginRequest

// bytes name = 1;
inline void LoginRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& LoginRequest::name() const {
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Agent.LoginRequest.name)
}
inline std::string* LoginRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Agent.LoginRequest.name)
  return _s;
}
inline const std::string& LoginRequest::_internal_name() const {
  return name_.Get();
}
inline void LoginRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_name() {
  // @@protoc_insertion_point(field_release:Agent.LoginRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginRequest.name)
}

// .Agent.Chap chap = 3;
inline bool LoginRequest::_internal_has_chap() const {
  return this != internal_default_instance() && chap_ != nullptr;
}
inline bool LoginRequest::has_chap() const {
  return _internal_has_chap();
}
inline void LoginRequest::clear_chap() {
  if (GetArenaForAllocation() == nullptr && chap_ != nullptr) {
    delete chap_;
  }
  chap_ = nullptr;
}
inline const ::Agent::Chap& LoginRequest::_internal_chap() const {
  const ::Agent::Chap* p = chap_;
  return p != nullptr ? *p : reinterpret_cast<const ::Agent::Chap&>(
      ::Agent::_Chap_default_instance_);
}
inline const ::Agent::Chap& LoginRequest::chap() const {
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.chap)
  return _internal_chap();
}
inline void LoginRequest::unsafe_arena_set_allocated_chap(
    ::Agent::Chap* chap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chap_);
  }
  chap_ = chap;
  if (chap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Agent.LoginRequest.chap)
}
inline ::Agent::Chap* LoginRequest::release_chap() {
  
  ::Agent::Chap* temp = chap_;
  chap_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Agent::Chap* LoginRequest::unsafe_arena_release_chap() {
  // @@protoc_insertion_point(field_release:Agent.LoginRequest.chap)
  
  ::Agent::Chap* temp = chap_;
  chap_ = nullptr;
  return temp;
}
inline ::Agent::Chap* LoginRequest::_internal_mutable_chap() {
  
  if (chap_ == nullptr) {
    auto* p = CreateMaybeMessage<::Agent::Chap>(GetArenaForAllocation());
    chap_ = p;
  }
  return chap_;
}
inline ::Agent::Chap* LoginRequest::mutable_chap() {
  ::Agent::Chap* _msg = _internal_mutable_chap();
  // @@protoc_insertion_point(field_mutable:Agent.LoginRequest.chap)
  return _msg;
}
inline void LoginRequest::set_allocated_chap(::Agent::Chap* chap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chap_;
  }
  if (chap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Agent::Chap>::GetOwningArena(chap);
    if (message_arena != submessage_arena) {
      chap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chap, submessage_arena);
    }
    
  } else {
    
  }
  chap_ = chap;
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginRequest.chap)
}

// .Agent.NetType net = 4;
inline void LoginRequest::clear_net() {
  net_ = 0;
}
inline ::Agent::NetType LoginRequest::_internal_net() const {
  return static_cast< ::Agent::NetType >(net_);
}
inline ::Agent::NetType LoginRequest::net() const {
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.net)
  return _internal_net();
}
inline void LoginRequest::_internal_set_net(::Agent::NetType value) {
  
  net_ = value;
}
inline void LoginRequest::set_net(::Agent::NetType value) {
  _internal_set_net(value);
  // @@protoc_insertion_point(field_set:Agent.LoginRequest.net)
}

// bytes token = 5;
inline void LoginRequest::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& LoginRequest::token() const {
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Agent.LoginRequest.token)
}
inline std::string* LoginRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:Agent.LoginRequest.token)
  return _s;
}
inline const std::string& LoginRequest::_internal_token() const {
  return token_.Get();
}
inline void LoginRequest::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_token() {
  // @@protoc_insertion_point(field_release:Agent.LoginRequest.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginRequest.token)
}

// -------------------------------------------------------------------

// LoginReponse

// bytes msg = 1;
inline void LoginReponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& LoginReponse::msg() const {
  // @@protoc_insertion_point(field_get:Agent.LoginReponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Agent.LoginReponse.msg)
}
inline std::string* LoginReponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Agent.LoginReponse.msg)
  return _s;
}
inline const std::string& LoginReponse::_internal_msg() const {
  return msg_.Get();
}
inline void LoginReponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReponse::release_msg() {
  // @@protoc_insertion_point(field_release:Agent.LoginReponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginReponse.msg)
}

// fixed32 ttl = 2;
inline void LoginReponse::clear_ttl() {
  ttl_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LoginReponse::_internal_ttl() const {
  return ttl_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LoginReponse::ttl() const {
  // @@protoc_insertion_point(field_get:Agent.LoginReponse.ttl)
  return _internal_ttl();
}
inline void LoginReponse::_internal_set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ttl_ = value;
}
inline void LoginReponse::set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:Agent.LoginReponse.ttl)
}

// -------------------------------------------------------------------

// NodeInfo

// bytes name = 1;
inline void NodeInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NodeInfo::name() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.name)
}
inline std::string* NodeInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Agent.NodeInfo.name)
  return _s;
}
inline const std::string& NodeInfo::_internal_name() const {
  return name_.Get();
}
inline void NodeInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NodeInfo::release_name() {
  // @@protoc_insertion_point(field_release:Agent.NodeInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NodeInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Agent.NodeInfo.name)
}

// .Agent.AppId cid = 2;
inline void NodeInfo::clear_cid() {
  cid_ = 0;
}
inline ::Agent::AppId NodeInfo::_internal_cid() const {
  return static_cast< ::Agent::AppId >(cid_);
}
inline ::Agent::AppId NodeInfo::cid() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.cid)
  return _internal_cid();
}
inline void NodeInfo::_internal_set_cid(::Agent::AppId value) {
  
  cid_ = value;
}
inline void NodeInfo::set_cid(::Agent::AppId value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.cid)
}

// .Agent.NodeStatus status = 3;
inline void NodeInfo::clear_status() {
  status_ = 0;
}
inline ::Agent::NodeStatus NodeInfo::_internal_status() const {
  return static_cast< ::Agent::NodeStatus >(status_);
}
inline ::Agent::NodeStatus NodeInfo::status() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.status)
  return _internal_status();
}
inline void NodeInfo::_internal_set_status(::Agent::NodeStatus value) {
  
  status_ = value;
}
inline void NodeInfo::set_status(::Agent::NodeStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.status)
}

// .Agent.NetType net = 4;
inline void NodeInfo::clear_net() {
  net_ = 0;
}
inline ::Agent::NetType NodeInfo::_internal_net() const {
  return static_cast< ::Agent::NetType >(net_);
}
inline ::Agent::NetType NodeInfo::net() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.net)
  return _internal_net();
}
inline void NodeInfo::_internal_set_net(::Agent::NetType value) {
  
  net_ = value;
}
inline void NodeInfo::set_net(::Agent::NetType value) {
  _internal_set_net(value);
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.net)
}

// -------------------------------------------------------------------

// HeartBeatRequest

// bytes name = 1;
inline void HeartBeatRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& HeartBeatRequest::name() const {
  // @@protoc_insertion_point(field_get:Agent.HeartBeatRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartBeatRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Agent.HeartBeatRequest.name)
}
inline std::string* HeartBeatRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Agent.HeartBeatRequest.name)
  return _s;
}
inline const std::string& HeartBeatRequest::_internal_name() const {
  return name_.Get();
}
inline void HeartBeatRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HeartBeatRequest::release_name() {
  // @@protoc_insertion_point(field_release:Agent.HeartBeatRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HeartBeatRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Agent.HeartBeatRequest.name)
}

// .Agent.AppId cid = 2;
inline void HeartBeatRequest::clear_cid() {
  cid_ = 0;
}
inline ::Agent::AppId HeartBeatRequest::_internal_cid() const {
  return static_cast< ::Agent::AppId >(cid_);
}
inline ::Agent::AppId HeartBeatRequest::cid() const {
  // @@protoc_insertion_point(field_get:Agent.HeartBeatRequest.cid)
  return _internal_cid();
}
inline void HeartBeatRequest::_internal_set_cid(::Agent::AppId value) {
  
  cid_ = value;
}
inline void HeartBeatRequest::set_cid(::Agent::AppId value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:Agent.HeartBeatRequest.cid)
}

// -------------------------------------------------------------------

// HeartBeatReponse

// repeated .Agent.NodeInfo nodes = 1;
inline int HeartBeatReponse::_internal_nodes_size() const {
  return nodes_.size();
}
inline int HeartBeatReponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void HeartBeatReponse::clear_nodes() {
  nodes_.Clear();
}
inline ::Agent::NodeInfo* HeartBeatReponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:Agent.HeartBeatReponse.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Agent::NodeInfo >*
HeartBeatReponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:Agent.HeartBeatReponse.nodes)
  return &nodes_;
}
inline const ::Agent::NodeInfo& HeartBeatReponse::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::Agent::NodeInfo& HeartBeatReponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:Agent.HeartBeatReponse.nodes)
  return _internal_nodes(index);
}
inline ::Agent::NodeInfo* HeartBeatReponse::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::Agent::NodeInfo* HeartBeatReponse::add_nodes() {
  ::Agent::NodeInfo* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:Agent.HeartBeatReponse.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Agent::NodeInfo >&
HeartBeatReponse::nodes() const {
  // @@protoc_insertion_point(field_list:Agent.HeartBeatReponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// AgentPdu

// .Agent.AgentBhs bhs = 1;
inline bool AgentPdu::_internal_has_bhs() const {
  return this != internal_default_instance() && bhs_ != nullptr;
}
inline bool AgentPdu::has_bhs() const {
  return _internal_has_bhs();
}
inline void AgentPdu::clear_bhs() {
  if (GetArenaForAllocation() == nullptr && bhs_ != nullptr) {
    delete bhs_;
  }
  bhs_ = nullptr;
}
inline const ::Agent::AgentBhs& AgentPdu::_internal_bhs() const {
  const ::Agent::AgentBhs* p = bhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::Agent::AgentBhs&>(
      ::Agent::_AgentBhs_default_instance_);
}
inline const ::Agent::AgentBhs& AgentPdu::bhs() const {
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.bhs)
  return _internal_bhs();
}
inline void AgentPdu::unsafe_arena_set_allocated_bhs(
    ::Agent::AgentBhs* bhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bhs_);
  }
  bhs_ = bhs;
  if (bhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Agent.AgentPdu.bhs)
}
inline ::Agent::AgentBhs* AgentPdu::release_bhs() {
  
  ::Agent::AgentBhs* temp = bhs_;
  bhs_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Agent::AgentBhs* AgentPdu::unsafe_arena_release_bhs() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.bhs)
  
  ::Agent::AgentBhs* temp = bhs_;
  bhs_ = nullptr;
  return temp;
}
inline ::Agent::AgentBhs* AgentPdu::_internal_mutable_bhs() {
  
  if (bhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::Agent::AgentBhs>(GetArenaForAllocation());
    bhs_ = p;
  }
  return bhs_;
}
inline ::Agent::AgentBhs* AgentPdu::mutable_bhs() {
  ::Agent::AgentBhs* _msg = _internal_mutable_bhs();
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.bhs)
  return _msg;
}
inline void AgentPdu::set_allocated_bhs(::Agent::AgentBhs* bhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bhs_;
  }
  if (bhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Agent::AgentBhs>::GetOwningArena(bhs);
    if (message_arena != submessage_arena) {
      bhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bhs, submessage_arena);
    }
    
  } else {
    
  }
  bhs_ = bhs;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.bhs)
}

// .Agent.LoginRequest reqLogin = 2;
inline bool AgentPdu::_internal_has_reqlogin() const {
  return this != internal_default_instance() && reqlogin_ != nullptr;
}
inline bool AgentPdu::has_reqlogin() const {
  return _internal_has_reqlogin();
}
inline void AgentPdu::clear_reqlogin() {
  if (GetArenaForAllocation() == nullptr && reqlogin_ != nullptr) {
    delete reqlogin_;
  }
  reqlogin_ = nullptr;
}
inline const ::Agent::LoginRequest& AgentPdu::_internal_reqlogin() const {
  const ::Agent::LoginRequest* p = reqlogin_;
  return p != nullptr ? *p : reinterpret_cast<const ::Agent::LoginRequest&>(
      ::Agent::_LoginRequest_default_instance_);
}
inline const ::Agent::LoginRequest& AgentPdu::reqlogin() const {
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.reqLogin)
  return _internal_reqlogin();
}
inline void AgentPdu::unsafe_arena_set_allocated_reqlogin(
    ::Agent::LoginRequest* reqlogin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reqlogin_);
  }
  reqlogin_ = reqlogin;
  if (reqlogin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Agent.AgentPdu.reqLogin)
}
inline ::Agent::LoginRequest* AgentPdu::release_reqlogin() {
  
  ::Agent::LoginRequest* temp = reqlogin_;
  reqlogin_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Agent::LoginRequest* AgentPdu::unsafe_arena_release_reqlogin() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.reqLogin)
  
  ::Agent::LoginRequest* temp = reqlogin_;
  reqlogin_ = nullptr;
  return temp;
}
inline ::Agent::LoginRequest* AgentPdu::_internal_mutable_reqlogin() {
  
  if (reqlogin_ == nullptr) {
    auto* p = CreateMaybeMessage<::Agent::LoginRequest>(GetArenaForAllocation());
    reqlogin_ = p;
  }
  return reqlogin_;
}
inline ::Agent::LoginRequest* AgentPdu::mutable_reqlogin() {
  ::Agent::LoginRequest* _msg = _internal_mutable_reqlogin();
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.reqLogin)
  return _msg;
}
inline void AgentPdu::set_allocated_reqlogin(::Agent::LoginRequest* reqlogin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reqlogin_;
  }
  if (reqlogin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Agent::LoginRequest>::GetOwningArena(reqlogin);
    if (message_arena != submessage_arena) {
      reqlogin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reqlogin, submessage_arena);
    }
    
  } else {
    
  }
  reqlogin_ = reqlogin;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.reqLogin)
}

// .Agent.LoginReponse rspLogin = 3;
inline bool AgentPdu::_internal_has_rsplogin() const {
  return this != internal_default_instance() && rsplogin_ != nullptr;
}
inline bool AgentPdu::has_rsplogin() const {
  return _internal_has_rsplogin();
}
inline void AgentPdu::clear_rsplogin() {
  if (GetArenaForAllocation() == nullptr && rsplogin_ != nullptr) {
    delete rsplogin_;
  }
  rsplogin_ = nullptr;
}
inline const ::Agent::LoginReponse& AgentPdu::_internal_rsplogin() const {
  const ::Agent::LoginReponse* p = rsplogin_;
  return p != nullptr ? *p : reinterpret_cast<const ::Agent::LoginReponse&>(
      ::Agent::_LoginReponse_default_instance_);
}
inline const ::Agent::LoginReponse& AgentPdu::rsplogin() const {
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.rspLogin)
  return _internal_rsplogin();
}
inline void AgentPdu::unsafe_arena_set_allocated_rsplogin(
    ::Agent::LoginReponse* rsplogin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rsplogin_);
  }
  rsplogin_ = rsplogin;
  if (rsplogin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Agent.AgentPdu.rspLogin)
}
inline ::Agent::LoginReponse* AgentPdu::release_rsplogin() {
  
  ::Agent::LoginReponse* temp = rsplogin_;
  rsplogin_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Agent::LoginReponse* AgentPdu::unsafe_arena_release_rsplogin() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.rspLogin)
  
  ::Agent::LoginReponse* temp = rsplogin_;
  rsplogin_ = nullptr;
  return temp;
}
inline ::Agent::LoginReponse* AgentPdu::_internal_mutable_rsplogin() {
  
  if (rsplogin_ == nullptr) {
    auto* p = CreateMaybeMessage<::Agent::LoginReponse>(GetArenaForAllocation());
    rsplogin_ = p;
  }
  return rsplogin_;
}
inline ::Agent::LoginReponse* AgentPdu::mutable_rsplogin() {
  ::Agent::LoginReponse* _msg = _internal_mutable_rsplogin();
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.rspLogin)
  return _msg;
}
inline void AgentPdu::set_allocated_rsplogin(::Agent::LoginReponse* rsplogin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rsplogin_;
  }
  if (rsplogin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Agent::LoginReponse>::GetOwningArena(rsplogin);
    if (message_arena != submessage_arena) {
      rsplogin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsplogin, submessage_arena);
    }
    
  } else {
    
  }
  rsplogin_ = rsplogin;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.rspLogin)
}

// .Agent.HeartBeatRequest reqHb = 4;
inline bool AgentPdu::_internal_has_reqhb() const {
  return this != internal_default_instance() && reqhb_ != nullptr;
}
inline bool AgentPdu::has_reqhb() const {
  return _internal_has_reqhb();
}
inline void AgentPdu::clear_reqhb() {
  if (GetArenaForAllocation() == nullptr && reqhb_ != nullptr) {
    delete reqhb_;
  }
  reqhb_ = nullptr;
}
inline const ::Agent::HeartBeatRequest& AgentPdu::_internal_reqhb() const {
  const ::Agent::HeartBeatRequest* p = reqhb_;
  return p != nullptr ? *p : reinterpret_cast<const ::Agent::HeartBeatRequest&>(
      ::Agent::_HeartBeatRequest_default_instance_);
}
inline const ::Agent::HeartBeatRequest& AgentPdu::reqhb() const {
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.reqHb)
  return _internal_reqhb();
}
inline void AgentPdu::unsafe_arena_set_allocated_reqhb(
    ::Agent::HeartBeatRequest* reqhb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reqhb_);
  }
  reqhb_ = reqhb;
  if (reqhb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Agent.AgentPdu.reqHb)
}
inline ::Agent::HeartBeatRequest* AgentPdu::release_reqhb() {
  
  ::Agent::HeartBeatRequest* temp = reqhb_;
  reqhb_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Agent::HeartBeatRequest* AgentPdu::unsafe_arena_release_reqhb() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.reqHb)
  
  ::Agent::HeartBeatRequest* temp = reqhb_;
  reqhb_ = nullptr;
  return temp;
}
inline ::Agent::HeartBeatRequest* AgentPdu::_internal_mutable_reqhb() {
  
  if (reqhb_ == nullptr) {
    auto* p = CreateMaybeMessage<::Agent::HeartBeatRequest>(GetArenaForAllocation());
    reqhb_ = p;
  }
  return reqhb_;
}
inline ::Agent::HeartBeatRequest* AgentPdu::mutable_reqhb() {
  ::Agent::HeartBeatRequest* _msg = _internal_mutable_reqhb();
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.reqHb)
  return _msg;
}
inline void AgentPdu::set_allocated_reqhb(::Agent::HeartBeatRequest* reqhb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reqhb_;
  }
  if (reqhb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Agent::HeartBeatRequest>::GetOwningArena(reqhb);
    if (message_arena != submessage_arena) {
      reqhb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reqhb, submessage_arena);
    }
    
  } else {
    
  }
  reqhb_ = reqhb;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.reqHb)
}

// .Agent.HeartBeatReponse rspHb = 5;
inline bool AgentPdu::_internal_has_rsphb() const {
  return this != internal_default_instance() && rsphb_ != nullptr;
}
inline bool AgentPdu::has_rsphb() const {
  return _internal_has_rsphb();
}
inline void AgentPdu::clear_rsphb() {
  if (GetArenaForAllocation() == nullptr && rsphb_ != nullptr) {
    delete rsphb_;
  }
  rsphb_ = nullptr;
}
inline const ::Agent::HeartBeatReponse& AgentPdu::_internal_rsphb() const {
  const ::Agent::HeartBeatReponse* p = rsphb_;
  return p != nullptr ? *p : reinterpret_cast<const ::Agent::HeartBeatReponse&>(
      ::Agent::_HeartBeatReponse_default_instance_);
}
inline const ::Agent::HeartBeatReponse& AgentPdu::rsphb() const {
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.rspHb)
  return _internal_rsphb();
}
inline void AgentPdu::unsafe_arena_set_allocated_rsphb(
    ::Agent::HeartBeatReponse* rsphb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rsphb_);
  }
  rsphb_ = rsphb;
  if (rsphb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Agent.AgentPdu.rspHb)
}
inline ::Agent::HeartBeatReponse* AgentPdu::release_rsphb() {
  
  ::Agent::HeartBeatReponse* temp = rsphb_;
  rsphb_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::Agent::HeartBeatReponse* AgentPdu::unsafe_arena_release_rsphb() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.rspHb)
  
  ::Agent::HeartBeatReponse* temp = rsphb_;
  rsphb_ = nullptr;
  return temp;
}
inline ::Agent::HeartBeatReponse* AgentPdu::_internal_mutable_rsphb() {
  
  if (rsphb_ == nullptr) {
    auto* p = CreateMaybeMessage<::Agent::HeartBeatReponse>(GetArenaForAllocation());
    rsphb_ = p;
  }
  return rsphb_;
}
inline ::Agent::HeartBeatReponse* AgentPdu::mutable_rsphb() {
  ::Agent::HeartBeatReponse* _msg = _internal_mutable_rsphb();
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.rspHb)
  return _msg;
}
inline void AgentPdu::set_allocated_rsphb(::Agent::HeartBeatReponse* rsphb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rsphb_;
  }
  if (rsphb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Agent::HeartBeatReponse>::GetOwningArena(rsphb);
    if (message_arena != submessage_arena) {
      rsphb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsphb, submessage_arena);
    }
    
  } else {
    
  }
  rsphb_ = rsphb;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.rspHb)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Agent

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Agent::Errno> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::Errno>() {
  return ::Agent::Errno_descriptor();
}
template <> struct is_proto_enum< ::Agent::Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::Command>() {
  return ::Agent::Command_descriptor();
}
template <> struct is_proto_enum< ::Agent::AppId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::AppId>() {
  return ::Agent::AppId_descriptor();
}
template <> struct is_proto_enum< ::Agent::PackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::PackType>() {
  return ::Agent::PackType_descriptor();
}
template <> struct is_proto_enum< ::Agent::Opcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::Opcode>() {
  return ::Agent::Opcode_descriptor();
}
template <> struct is_proto_enum< ::Agent::NetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::NetType>() {
  return ::Agent::NetType_descriptor();
}
template <> struct is_proto_enum< ::Agent::NodeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::NodeStatus>() {
  return ::Agent::NodeStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Agent_2eproto
