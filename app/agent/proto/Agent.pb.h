// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Agent.proto

#ifndef PROTOBUF_INCLUDED_Agent_2eproto
#define PROTOBUF_INCLUDED_Agent_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Agent_2eproto 

namespace protobuf_Agent_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Agent_2eproto
namespace Agent {
class AgentBhs;
class AgentBhsDefaultTypeInternal;
extern AgentBhsDefaultTypeInternal _AgentBhs_default_instance_;
class AgentPdu;
class AgentPduDefaultTypeInternal;
extern AgentPduDefaultTypeInternal _AgentPdu_default_instance_;
class Chap;
class ChapDefaultTypeInternal;
extern ChapDefaultTypeInternal _Chap_default_instance_;
class HeartBeatReponse;
class HeartBeatReponseDefaultTypeInternal;
extern HeartBeatReponseDefaultTypeInternal _HeartBeatReponse_default_instance_;
class HeartBeatRequest;
class HeartBeatRequestDefaultTypeInternal;
extern HeartBeatRequestDefaultTypeInternal _HeartBeatRequest_default_instance_;
class LoginReponse;
class LoginReponseDefaultTypeInternal;
extern LoginReponseDefaultTypeInternal _LoginReponse_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
}  // namespace Agent
namespace google {
namespace protobuf {
template<> ::Agent::AgentBhs* Arena::CreateMaybeMessage<::Agent::AgentBhs>(Arena*);
template<> ::Agent::AgentPdu* Arena::CreateMaybeMessage<::Agent::AgentPdu>(Arena*);
template<> ::Agent::Chap* Arena::CreateMaybeMessage<::Agent::Chap>(Arena*);
template<> ::Agent::HeartBeatReponse* Arena::CreateMaybeMessage<::Agent::HeartBeatReponse>(Arena*);
template<> ::Agent::HeartBeatRequest* Arena::CreateMaybeMessage<::Agent::HeartBeatRequest>(Arena*);
template<> ::Agent::LoginReponse* Arena::CreateMaybeMessage<::Agent::LoginReponse>(Arena*);
template<> ::Agent::LoginRequest* Arena::CreateMaybeMessage<::Agent::LoginRequest>(Arena*);
template<> ::Agent::NodeInfo* Arena::CreateMaybeMessage<::Agent::NodeInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Agent {

enum Errno {
  ERR_EXEC_SUCESS = 0,
  ERR_EXEC_FAILURE = 1,
  ERR_LOGIN_SUCESS = 2,
  ERR_LOGIN_FAILURE = 3,
  ERR_LOGIN_UNAUTH = 4,
  ERR_PEER_OFFLINE = 5,
  ERR_SEND_TIMEROUT = 6,
  ERR_RECV_TIMEROUT = 7,
  ERR_CANNOT_IN_LOOP = 8,
  ERR_AGENT_NOT_START = 9,
  ERR_ENCODE_FAILURE = 10,
  ERR_DECODE_FAILURE = 11,
  ERR_UNKNOWN_MAGIC = 12,
  ERR_UNKNOWN_COMMAND = 13,
  ERR_REPEAT_REGISTERED = 14,
  ERR_SERVER_INNER_ERR = 15,
  Errno_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Errno_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Errno_IsValid(int value);
const Errno Errno_MIN = ERR_EXEC_SUCESS;
const Errno Errno_MAX = ERR_SERVER_INNER_ERR;
const int Errno_ARRAYSIZE = Errno_MAX + 1;

const ::google::protobuf::EnumDescriptor* Errno_descriptor();
inline const ::std::string& Errno_Name(Errno value) {
  return ::google::protobuf::internal::NameOfEnum(
    Errno_descriptor(), value);
}
inline bool Errno_Parse(
    const ::std::string& name, Errno* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Errno>(
    Errno_descriptor(), name, value);
}
enum Command {
  CMD_REQ_NODE_REGISTER = 0,
  CMD_REQ_NODE_UNREGISTER = 1,
  CMD_REQ_NODE_HEARTBEAT = 2,
  CMD_REQ_NODE_STATUS_REPORT = 3,
  CMD_REQ_NODE_LOGGER_COLLECT = 4,
  CMD_REQ_NODE_LOGGER_LEVEL = 5,
  CMD_REQ_NODE_QUERY = 6,
  CMD_REQ_NODE_NOTIFY = 7,
  CMD_REQ_NODE_LEADER_ELECTION = 8,
  CMD_REQ_STORAGE_READ = 256,
  CMD_REQ_STORAGE_WRITE = 257,
  CMD_REQ_MOBILE_READ = 258,
  CMD_REQ_MOBILE_WRITE = 259,
  Command_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Command_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Command_IsValid(int value);
const Command Command_MIN = CMD_REQ_NODE_REGISTER;
const Command Command_MAX = CMD_REQ_MOBILE_WRITE;
const int Command_ARRAYSIZE = Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_descriptor();
inline const ::std::string& Command_Name(Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_descriptor(), value);
}
inline bool Command_Parse(
    const ::std::string& name, Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
enum AppId {
  APP_ONESELF = 0,
  APP_AGENT = 1,
  APP_GUARD = 2,
  APP_MOBILE = 3,
  APP_DLNA = 4,
  APP_UPNP = 5,
  APP_DDNS = 6,
  AppId_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AppId_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AppId_IsValid(int value);
const AppId AppId_MIN = APP_ONESELF;
const AppId AppId_MAX = APP_DDNS;
const int AppId_ARRAYSIZE = AppId_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppId_descriptor();
inline const ::std::string& AppId_Name(AppId value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppId_descriptor(), value);
}
inline bool AppId_Parse(
    const ::std::string& name, AppId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppId>(
    AppId_descriptor(), name, value);
}
enum PackType {
  PACK_BINNARY = 0,
  PACK_JSON = 1,
  PACK_PROTOBUF = 2,
  PACK_BUTT = 3,
  PackType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PackType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PackType_IsValid(int value);
const PackType PackType_MIN = PACK_BINNARY;
const PackType PackType_MAX = PACK_BUTT;
const int PackType_ARRAYSIZE = PackType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PackType_descriptor();
inline const ::std::string& PackType_Name(PackType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PackType_descriptor(), value);
}
inline bool PackType_Parse(
    const ::std::string& name, PackType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PackType>(
    PackType_descriptor(), name, value);
}
enum Opcode {
  OP_REQ = 0,
  OP_RSP = 1,
  Opcode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Opcode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Opcode_IsValid(int value);
const Opcode Opcode_MIN = OP_REQ;
const Opcode Opcode_MAX = OP_RSP;
const int Opcode_ARRAYSIZE = Opcode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Opcode_descriptor();
inline const ::std::string& Opcode_Name(Opcode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Opcode_descriptor(), value);
}
inline bool Opcode_Parse(
    const ::std::string& name, Opcode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Opcode>(
    Opcode_descriptor(), name, value);
}
enum NetType {
  NET_ETH = 0,
  NET_WLAN = 1,
  NET_MOBILE = 2,
  NetType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NetType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NetType_IsValid(int value);
const NetType NetType_MIN = NET_ETH;
const NetType NetType_MAX = NET_MOBILE;
const int NetType_ARRAYSIZE = NetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetType_descriptor();
inline const ::std::string& NetType_Name(NetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetType_descriptor(), value);
}
inline bool NetType_Parse(
    const ::std::string& name, NetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetType>(
    NetType_descriptor(), name, value);
}
enum NodeStatus {
  STATUS_ONLINE = 0,
  STATUS_OFFLINE = 1,
  STATUS_IDLE = 2,
  STATUS_BUSY = 3,
  NodeStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NodeStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NodeStatus_IsValid(int value);
const NodeStatus NodeStatus_MIN = STATUS_ONLINE;
const NodeStatus NodeStatus_MAX = STATUS_BUSY;
const int NodeStatus_ARRAYSIZE = NodeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeStatus_descriptor();
inline const ::std::string& NodeStatus_Name(NodeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeStatus_descriptor(), value);
}
inline bool NodeStatus_Parse(
    const ::std::string& name, NodeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStatus>(
    NodeStatus_descriptor(), name, value);
}
// ===================================================================

class AgentBhs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.AgentBhs) */ {
 public:
  AgentBhs();
  virtual ~AgentBhs();

  AgentBhs(const AgentBhs& from);

  inline AgentBhs& operator=(const AgentBhs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AgentBhs(AgentBhs&& from) noexcept
    : AgentBhs() {
    *this = ::std::move(from);
  }

  inline AgentBhs& operator=(AgentBhs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentBhs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AgentBhs* internal_default_instance() {
    return reinterpret_cast<const AgentBhs*>(
               &_AgentBhs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AgentBhs* other);
  friend void swap(AgentBhs& a, AgentBhs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AgentBhs* New() const final {
    return CreateMaybeMessage<AgentBhs>(NULL);
  }

  AgentBhs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AgentBhs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AgentBhs& from);
  void MergeFrom(const AgentBhs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentBhs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed64 verify = 1;
  void clear_verify();
  static const int kVerifyFieldNumber = 1;
  ::google::protobuf::uint64 verify() const;
  void set_verify(::google::protobuf::uint64 value);

  // fixed64 router = 2;
  void clear_router();
  static const int kRouterFieldNumber = 2;
  ::google::protobuf::uint64 router() const;
  void set_router(::google::protobuf::uint64 value);

  // fixed64 command = 3;
  void clear_command();
  static const int kCommandFieldNumber = 3;
  ::google::protobuf::uint64 command() const;
  void set_command(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Agent.AgentBhs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 verify_;
  ::google::protobuf::uint64 router_;
  ::google::protobuf::uint64 command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Chap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.Chap) */ {
 public:
  Chap();
  virtual ~Chap();

  Chap(const Chap& from);

  inline Chap& operator=(const Chap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chap(Chap&& from) noexcept
    : Chap() {
    *this = ::std::move(from);
  }

  inline Chap& operator=(Chap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chap* internal_default_instance() {
    return reinterpret_cast<const Chap*>(
               &_Chap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Chap* other);
  friend void swap(Chap& a, Chap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chap* New() const final {
    return CreateMaybeMessage<Chap>(NULL);
  }

  Chap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chap& from);
  void MergeFrom(const Chap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 3;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // uint32 phase = 1;
  void clear_phase();
  static const int kPhaseFieldNumber = 1;
  ::google::protobuf::uint32 phase() const;
  void set_phase(::google::protobuf::uint32 value);

  // uint32 alg = 2;
  void clear_alg();
  static const int kAlgFieldNumber = 2;
  ::google::protobuf::uint32 alg() const;
  void set_alg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Agent.Chap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint32 phase_;
  ::google::protobuf::uint32 alg_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(NULL);
  }

  LoginRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes token = 5;
  void clear_token();
  static const int kTokenFieldNumber = 5;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // .Agent.Chap chap = 3;
  bool has_chap() const;
  void clear_chap();
  static const int kChapFieldNumber = 3;
  private:
  const ::Agent::Chap& _internal_chap() const;
  public:
  const ::Agent::Chap& chap() const;
  ::Agent::Chap* release_chap();
  ::Agent::Chap* mutable_chap();
  void set_allocated_chap(::Agent::Chap* chap);

  // .Agent.NetType net = 4;
  void clear_net();
  static const int kNetFieldNumber = 4;
  ::Agent::NetType net() const;
  void set_net(::Agent::NetType value);

  // @@protoc_insertion_point(class_scope:Agent.LoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::Agent::Chap* chap_;
  int net_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginReponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.LoginReponse) */ {
 public:
  LoginReponse();
  virtual ~LoginReponse();

  LoginReponse(const LoginReponse& from);

  inline LoginReponse& operator=(const LoginReponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginReponse(LoginReponse&& from) noexcept
    : LoginReponse() {
    *this = ::std::move(from);
  }

  inline LoginReponse& operator=(LoginReponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReponse* internal_default_instance() {
    return reinterpret_cast<const LoginReponse*>(
               &_LoginReponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LoginReponse* other);
  friend void swap(LoginReponse& a, LoginReponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginReponse* New() const final {
    return CreateMaybeMessage<LoginReponse>(NULL);
  }

  LoginReponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LoginReponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LoginReponse& from);
  void MergeFrom(const LoginReponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // fixed32 ttl = 2;
  void clear_ttl();
  static const int kTtlFieldNumber = 2;
  ::google::protobuf::uint32 ttl() const;
  void set_ttl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Agent.LoginReponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::uint32 ttl_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(NodeInfo* other);
  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(NULL);
  }

  NodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Agent.AppId cid = 2;
  void clear_cid();
  static const int kCidFieldNumber = 2;
  ::Agent::AppId cid() const;
  void set_cid(::Agent::AppId value);

  // .Agent.NodeStatus status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::Agent::NodeStatus status() const;
  void set_status(::Agent::NodeStatus value);

  // .Agent.NetType net = 4;
  void clear_net();
  static const int kNetFieldNumber = 4;
  ::Agent::NetType net() const;
  void set_net(::Agent::NetType value);

  // @@protoc_insertion_point(class_scope:Agent.NodeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int cid_;
  int status_;
  int net_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartBeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.HeartBeatRequest) */ {
 public:
  HeartBeatRequest();
  virtual ~HeartBeatRequest();

  HeartBeatRequest(const HeartBeatRequest& from);

  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartBeatRequest(HeartBeatRequest&& from) noexcept
    : HeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartBeatRequest& operator=(HeartBeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartBeatRequest*>(
               &_HeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(HeartBeatRequest* other);
  friend void swap(HeartBeatRequest& a, HeartBeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartBeatRequest* New() const final {
    return CreateMaybeMessage<HeartBeatRequest>(NULL);
  }

  HeartBeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartBeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartBeatRequest& from);
  void MergeFrom(const HeartBeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Agent.AppId cid = 2;
  void clear_cid();
  static const int kCidFieldNumber = 2;
  ::Agent::AppId cid() const;
  void set_cid(::Agent::AppId value);

  // @@protoc_insertion_point(class_scope:Agent.HeartBeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int cid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartBeatReponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.HeartBeatReponse) */ {
 public:
  HeartBeatReponse();
  virtual ~HeartBeatReponse();

  HeartBeatReponse(const HeartBeatReponse& from);

  inline HeartBeatReponse& operator=(const HeartBeatReponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartBeatReponse(HeartBeatReponse&& from) noexcept
    : HeartBeatReponse() {
    *this = ::std::move(from);
  }

  inline HeartBeatReponse& operator=(HeartBeatReponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatReponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartBeatReponse* internal_default_instance() {
    return reinterpret_cast<const HeartBeatReponse*>(
               &_HeartBeatReponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(HeartBeatReponse* other);
  friend void swap(HeartBeatReponse& a, HeartBeatReponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartBeatReponse* New() const final {
    return CreateMaybeMessage<HeartBeatReponse>(NULL);
  }

  HeartBeatReponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartBeatReponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartBeatReponse& from);
  void MergeFrom(const HeartBeatReponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeatReponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Agent.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::Agent::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::Agent::NodeInfo >*
      mutable_nodes();
  const ::Agent::NodeInfo& nodes(int index) const;
  ::Agent::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::Agent::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:Agent.HeartBeatReponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Agent::NodeInfo > nodes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AgentPdu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Agent.AgentPdu) */ {
 public:
  AgentPdu();
  virtual ~AgentPdu();

  AgentPdu(const AgentPdu& from);

  inline AgentPdu& operator=(const AgentPdu& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AgentPdu(AgentPdu&& from) noexcept
    : AgentPdu() {
    *this = ::std::move(from);
  }

  inline AgentPdu& operator=(AgentPdu&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentPdu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AgentPdu* internal_default_instance() {
    return reinterpret_cast<const AgentPdu*>(
               &_AgentPdu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AgentPdu* other);
  friend void swap(AgentPdu& a, AgentPdu& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AgentPdu* New() const final {
    return CreateMaybeMessage<AgentPdu>(NULL);
  }

  AgentPdu* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AgentPdu>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AgentPdu& from);
  void MergeFrom(const AgentPdu& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentPdu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Agent.AgentBhs bhs = 1;
  bool has_bhs() const;
  void clear_bhs();
  static const int kBhsFieldNumber = 1;
  private:
  const ::Agent::AgentBhs& _internal_bhs() const;
  public:
  const ::Agent::AgentBhs& bhs() const;
  ::Agent::AgentBhs* release_bhs();
  ::Agent::AgentBhs* mutable_bhs();
  void set_allocated_bhs(::Agent::AgentBhs* bhs);

  // .Agent.LoginRequest reqLogin = 2;
  bool has_reqlogin() const;
  void clear_reqlogin();
  static const int kReqLoginFieldNumber = 2;
  private:
  const ::Agent::LoginRequest& _internal_reqlogin() const;
  public:
  const ::Agent::LoginRequest& reqlogin() const;
  ::Agent::LoginRequest* release_reqlogin();
  ::Agent::LoginRequest* mutable_reqlogin();
  void set_allocated_reqlogin(::Agent::LoginRequest* reqlogin);

  // .Agent.LoginReponse rspLogin = 3;
  bool has_rsplogin() const;
  void clear_rsplogin();
  static const int kRspLoginFieldNumber = 3;
  private:
  const ::Agent::LoginReponse& _internal_rsplogin() const;
  public:
  const ::Agent::LoginReponse& rsplogin() const;
  ::Agent::LoginReponse* release_rsplogin();
  ::Agent::LoginReponse* mutable_rsplogin();
  void set_allocated_rsplogin(::Agent::LoginReponse* rsplogin);

  // .Agent.HeartBeatRequest reqHb = 4;
  bool has_reqhb() const;
  void clear_reqhb();
  static const int kReqHbFieldNumber = 4;
  private:
  const ::Agent::HeartBeatRequest& _internal_reqhb() const;
  public:
  const ::Agent::HeartBeatRequest& reqhb() const;
  ::Agent::HeartBeatRequest* release_reqhb();
  ::Agent::HeartBeatRequest* mutable_reqhb();
  void set_allocated_reqhb(::Agent::HeartBeatRequest* reqhb);

  // .Agent.HeartBeatReponse rspHb = 5;
  bool has_rsphb() const;
  void clear_rsphb();
  static const int kRspHbFieldNumber = 5;
  private:
  const ::Agent::HeartBeatReponse& _internal_rsphb() const;
  public:
  const ::Agent::HeartBeatReponse& rsphb() const;
  ::Agent::HeartBeatReponse* release_rsphb();
  ::Agent::HeartBeatReponse* mutable_rsphb();
  void set_allocated_rsphb(::Agent::HeartBeatReponse* rsphb);

  // @@protoc_insertion_point(class_scope:Agent.AgentPdu)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Agent::AgentBhs* bhs_;
  ::Agent::LoginRequest* reqlogin_;
  ::Agent::LoginReponse* rsplogin_;
  ::Agent::HeartBeatRequest* reqhb_;
  ::Agent::HeartBeatReponse* rsphb_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Agent_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AgentBhs

// fixed64 verify = 1;
inline void AgentBhs::clear_verify() {
  verify_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AgentBhs::verify() const {
  // @@protoc_insertion_point(field_get:Agent.AgentBhs.verify)
  return verify_;
}
inline void AgentBhs::set_verify(::google::protobuf::uint64 value) {
  
  verify_ = value;
  // @@protoc_insertion_point(field_set:Agent.AgentBhs.verify)
}

// fixed64 router = 2;
inline void AgentBhs::clear_router() {
  router_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AgentBhs::router() const {
  // @@protoc_insertion_point(field_get:Agent.AgentBhs.router)
  return router_;
}
inline void AgentBhs::set_router(::google::protobuf::uint64 value) {
  
  router_ = value;
  // @@protoc_insertion_point(field_set:Agent.AgentBhs.router)
}

// fixed64 command = 3;
inline void AgentBhs::clear_command() {
  command_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AgentBhs::command() const {
  // @@protoc_insertion_point(field_get:Agent.AgentBhs.command)
  return command_;
}
inline void AgentBhs::set_command(::google::protobuf::uint64 value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:Agent.AgentBhs.command)
}

// -------------------------------------------------------------------

// Chap

// uint32 phase = 1;
inline void Chap::clear_phase() {
  phase_ = 0u;
}
inline ::google::protobuf::uint32 Chap::phase() const {
  // @@protoc_insertion_point(field_get:Agent.Chap.phase)
  return phase_;
}
inline void Chap::set_phase(::google::protobuf::uint32 value) {
  
  phase_ = value;
  // @@protoc_insertion_point(field_set:Agent.Chap.phase)
}

// uint32 alg = 2;
inline void Chap::clear_alg() {
  alg_ = 0u;
}
inline ::google::protobuf::uint32 Chap::alg() const {
  // @@protoc_insertion_point(field_get:Agent.Chap.alg)
  return alg_;
}
inline void Chap::set_alg(::google::protobuf::uint32 value) {
  
  alg_ = value;
  // @@protoc_insertion_point(field_set:Agent.Chap.alg)
}

// bytes hash = 3;
inline void Chap::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chap::hash() const {
  // @@protoc_insertion_point(field_get:Agent.Chap.hash)
  return hash_.GetNoArena();
}
inline void Chap::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Agent.Chap.hash)
}
#if LANG_CXX11
inline void Chap::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Agent.Chap.hash)
}
#endif
inline void Chap::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Agent.Chap.hash)
}
inline void Chap::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Agent.Chap.hash)
}
inline ::std::string* Chap::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:Agent.Chap.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chap::release_hash() {
  // @@protoc_insertion_point(field_release:Agent.Chap.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chap::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:Agent.Chap.hash)
}

// -------------------------------------------------------------------

// LoginRequest

// bytes name = 1;
inline void LoginRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::name() const {
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.name)
  return name_.GetNoArena();
}
inline void LoginRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Agent.LoginRequest.name)
}
#if LANG_CXX11
inline void LoginRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Agent.LoginRequest.name)
}
#endif
inline void LoginRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Agent.LoginRequest.name)
}
inline void LoginRequest::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Agent.LoginRequest.name)
}
inline ::std::string* LoginRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Agent.LoginRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_name() {
  // @@protoc_insertion_point(field_release:Agent.LoginRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginRequest.name)
}

// .Agent.Chap chap = 3;
inline bool LoginRequest::has_chap() const {
  return this != internal_default_instance() && chap_ != NULL;
}
inline void LoginRequest::clear_chap() {
  if (GetArenaNoVirtual() == NULL && chap_ != NULL) {
    delete chap_;
  }
  chap_ = NULL;
}
inline const ::Agent::Chap& LoginRequest::_internal_chap() const {
  return *chap_;
}
inline const ::Agent::Chap& LoginRequest::chap() const {
  const ::Agent::Chap* p = chap_;
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.chap)
  return p != NULL ? *p : *reinterpret_cast<const ::Agent::Chap*>(
      &::Agent::_Chap_default_instance_);
}
inline ::Agent::Chap* LoginRequest::release_chap() {
  // @@protoc_insertion_point(field_release:Agent.LoginRequest.chap)
  
  ::Agent::Chap* temp = chap_;
  chap_ = NULL;
  return temp;
}
inline ::Agent::Chap* LoginRequest::mutable_chap() {
  
  if (chap_ == NULL) {
    auto* p = CreateMaybeMessage<::Agent::Chap>(GetArenaNoVirtual());
    chap_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Agent.LoginRequest.chap)
  return chap_;
}
inline void LoginRequest::set_allocated_chap(::Agent::Chap* chap) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chap_;
  }
  if (chap) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chap = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chap, submessage_arena);
    }
    
  } else {
    
  }
  chap_ = chap;
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginRequest.chap)
}

// .Agent.NetType net = 4;
inline void LoginRequest::clear_net() {
  net_ = 0;
}
inline ::Agent::NetType LoginRequest::net() const {
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.net)
  return static_cast< ::Agent::NetType >(net_);
}
inline void LoginRequest::set_net(::Agent::NetType value) {
  
  net_ = value;
  // @@protoc_insertion_point(field_set:Agent.LoginRequest.net)
}

// bytes token = 5;
inline void LoginRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::token() const {
  // @@protoc_insertion_point(field_get:Agent.LoginRequest.token)
  return token_.GetNoArena();
}
inline void LoginRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Agent.LoginRequest.token)
}
#if LANG_CXX11
inline void LoginRequest::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Agent.LoginRequest.token)
}
#endif
inline void LoginRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Agent.LoginRequest.token)
}
inline void LoginRequest::set_token(const void* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Agent.LoginRequest.token)
}
inline ::std::string* LoginRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:Agent.LoginRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_token() {
  // @@protoc_insertion_point(field_release:Agent.LoginRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginRequest.token)
}

// -------------------------------------------------------------------

// LoginReponse

// bytes msg = 1;
inline void LoginReponse::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReponse::msg() const {
  // @@protoc_insertion_point(field_get:Agent.LoginReponse.msg)
  return msg_.GetNoArena();
}
inline void LoginReponse::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Agent.LoginReponse.msg)
}
#if LANG_CXX11
inline void LoginReponse::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Agent.LoginReponse.msg)
}
#endif
inline void LoginReponse::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Agent.LoginReponse.msg)
}
inline void LoginReponse::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Agent.LoginReponse.msg)
}
inline ::std::string* LoginReponse::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Agent.LoginReponse.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReponse::release_msg() {
  // @@protoc_insertion_point(field_release:Agent.LoginReponse.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReponse::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Agent.LoginReponse.msg)
}

// fixed32 ttl = 2;
inline void LoginReponse::clear_ttl() {
  ttl_ = 0u;
}
inline ::google::protobuf::uint32 LoginReponse::ttl() const {
  // @@protoc_insertion_point(field_get:Agent.LoginReponse.ttl)
  return ttl_;
}
inline void LoginReponse::set_ttl(::google::protobuf::uint32 value) {
  
  ttl_ = value;
  // @@protoc_insertion_point(field_set:Agent.LoginReponse.ttl)
}

// -------------------------------------------------------------------

// NodeInfo

// bytes name = 1;
inline void NodeInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeInfo::name() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.name)
  return name_.GetNoArena();
}
inline void NodeInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.name)
}
#if LANG_CXX11
inline void NodeInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Agent.NodeInfo.name)
}
#endif
inline void NodeInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Agent.NodeInfo.name)
}
inline void NodeInfo::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Agent.NodeInfo.name)
}
inline ::std::string* NodeInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Agent.NodeInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_name() {
  // @@protoc_insertion_point(field_release:Agent.NodeInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Agent.NodeInfo.name)
}

// .Agent.AppId cid = 2;
inline void NodeInfo::clear_cid() {
  cid_ = 0;
}
inline ::Agent::AppId NodeInfo::cid() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.cid)
  return static_cast< ::Agent::AppId >(cid_);
}
inline void NodeInfo::set_cid(::Agent::AppId value) {
  
  cid_ = value;
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.cid)
}

// .Agent.NodeStatus status = 3;
inline void NodeInfo::clear_status() {
  status_ = 0;
}
inline ::Agent::NodeStatus NodeInfo::status() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.status)
  return static_cast< ::Agent::NodeStatus >(status_);
}
inline void NodeInfo::set_status(::Agent::NodeStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.status)
}

// .Agent.NetType net = 4;
inline void NodeInfo::clear_net() {
  net_ = 0;
}
inline ::Agent::NetType NodeInfo::net() const {
  // @@protoc_insertion_point(field_get:Agent.NodeInfo.net)
  return static_cast< ::Agent::NetType >(net_);
}
inline void NodeInfo::set_net(::Agent::NetType value) {
  
  net_ = value;
  // @@protoc_insertion_point(field_set:Agent.NodeInfo.net)
}

// -------------------------------------------------------------------

// HeartBeatRequest

// bytes name = 1;
inline void HeartBeatRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeartBeatRequest::name() const {
  // @@protoc_insertion_point(field_get:Agent.HeartBeatRequest.name)
  return name_.GetNoArena();
}
inline void HeartBeatRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Agent.HeartBeatRequest.name)
}
#if LANG_CXX11
inline void HeartBeatRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Agent.HeartBeatRequest.name)
}
#endif
inline void HeartBeatRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Agent.HeartBeatRequest.name)
}
inline void HeartBeatRequest::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Agent.HeartBeatRequest.name)
}
inline ::std::string* HeartBeatRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Agent.HeartBeatRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartBeatRequest::release_name() {
  // @@protoc_insertion_point(field_release:Agent.HeartBeatRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartBeatRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Agent.HeartBeatRequest.name)
}

// .Agent.AppId cid = 2;
inline void HeartBeatRequest::clear_cid() {
  cid_ = 0;
}
inline ::Agent::AppId HeartBeatRequest::cid() const {
  // @@protoc_insertion_point(field_get:Agent.HeartBeatRequest.cid)
  return static_cast< ::Agent::AppId >(cid_);
}
inline void HeartBeatRequest::set_cid(::Agent::AppId value) {
  
  cid_ = value;
  // @@protoc_insertion_point(field_set:Agent.HeartBeatRequest.cid)
}

// -------------------------------------------------------------------

// HeartBeatReponse

// repeated .Agent.NodeInfo nodes = 1;
inline int HeartBeatReponse::nodes_size() const {
  return nodes_.size();
}
inline void HeartBeatReponse::clear_nodes() {
  nodes_.Clear();
}
inline ::Agent::NodeInfo* HeartBeatReponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:Agent.HeartBeatReponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Agent::NodeInfo >*
HeartBeatReponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:Agent.HeartBeatReponse.nodes)
  return &nodes_;
}
inline const ::Agent::NodeInfo& HeartBeatReponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:Agent.HeartBeatReponse.nodes)
  return nodes_.Get(index);
}
inline ::Agent::NodeInfo* HeartBeatReponse::add_nodes() {
  // @@protoc_insertion_point(field_add:Agent.HeartBeatReponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Agent::NodeInfo >&
HeartBeatReponse::nodes() const {
  // @@protoc_insertion_point(field_list:Agent.HeartBeatReponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// AgentPdu

// .Agent.AgentBhs bhs = 1;
inline bool AgentPdu::has_bhs() const {
  return this != internal_default_instance() && bhs_ != NULL;
}
inline void AgentPdu::clear_bhs() {
  if (GetArenaNoVirtual() == NULL && bhs_ != NULL) {
    delete bhs_;
  }
  bhs_ = NULL;
}
inline const ::Agent::AgentBhs& AgentPdu::_internal_bhs() const {
  return *bhs_;
}
inline const ::Agent::AgentBhs& AgentPdu::bhs() const {
  const ::Agent::AgentBhs* p = bhs_;
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.bhs)
  return p != NULL ? *p : *reinterpret_cast<const ::Agent::AgentBhs*>(
      &::Agent::_AgentBhs_default_instance_);
}
inline ::Agent::AgentBhs* AgentPdu::release_bhs() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.bhs)
  
  ::Agent::AgentBhs* temp = bhs_;
  bhs_ = NULL;
  return temp;
}
inline ::Agent::AgentBhs* AgentPdu::mutable_bhs() {
  
  if (bhs_ == NULL) {
    auto* p = CreateMaybeMessage<::Agent::AgentBhs>(GetArenaNoVirtual());
    bhs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.bhs)
  return bhs_;
}
inline void AgentPdu::set_allocated_bhs(::Agent::AgentBhs* bhs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bhs_;
  }
  if (bhs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bhs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bhs, submessage_arena);
    }
    
  } else {
    
  }
  bhs_ = bhs;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.bhs)
}

// .Agent.LoginRequest reqLogin = 2;
inline bool AgentPdu::has_reqlogin() const {
  return this != internal_default_instance() && reqlogin_ != NULL;
}
inline void AgentPdu::clear_reqlogin() {
  if (GetArenaNoVirtual() == NULL && reqlogin_ != NULL) {
    delete reqlogin_;
  }
  reqlogin_ = NULL;
}
inline const ::Agent::LoginRequest& AgentPdu::_internal_reqlogin() const {
  return *reqlogin_;
}
inline const ::Agent::LoginRequest& AgentPdu::reqlogin() const {
  const ::Agent::LoginRequest* p = reqlogin_;
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.reqLogin)
  return p != NULL ? *p : *reinterpret_cast<const ::Agent::LoginRequest*>(
      &::Agent::_LoginRequest_default_instance_);
}
inline ::Agent::LoginRequest* AgentPdu::release_reqlogin() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.reqLogin)
  
  ::Agent::LoginRequest* temp = reqlogin_;
  reqlogin_ = NULL;
  return temp;
}
inline ::Agent::LoginRequest* AgentPdu::mutable_reqlogin() {
  
  if (reqlogin_ == NULL) {
    auto* p = CreateMaybeMessage<::Agent::LoginRequest>(GetArenaNoVirtual());
    reqlogin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.reqLogin)
  return reqlogin_;
}
inline void AgentPdu::set_allocated_reqlogin(::Agent::LoginRequest* reqlogin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqlogin_;
  }
  if (reqlogin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqlogin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqlogin, submessage_arena);
    }
    
  } else {
    
  }
  reqlogin_ = reqlogin;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.reqLogin)
}

// .Agent.LoginReponse rspLogin = 3;
inline bool AgentPdu::has_rsplogin() const {
  return this != internal_default_instance() && rsplogin_ != NULL;
}
inline void AgentPdu::clear_rsplogin() {
  if (GetArenaNoVirtual() == NULL && rsplogin_ != NULL) {
    delete rsplogin_;
  }
  rsplogin_ = NULL;
}
inline const ::Agent::LoginReponse& AgentPdu::_internal_rsplogin() const {
  return *rsplogin_;
}
inline const ::Agent::LoginReponse& AgentPdu::rsplogin() const {
  const ::Agent::LoginReponse* p = rsplogin_;
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.rspLogin)
  return p != NULL ? *p : *reinterpret_cast<const ::Agent::LoginReponse*>(
      &::Agent::_LoginReponse_default_instance_);
}
inline ::Agent::LoginReponse* AgentPdu::release_rsplogin() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.rspLogin)
  
  ::Agent::LoginReponse* temp = rsplogin_;
  rsplogin_ = NULL;
  return temp;
}
inline ::Agent::LoginReponse* AgentPdu::mutable_rsplogin() {
  
  if (rsplogin_ == NULL) {
    auto* p = CreateMaybeMessage<::Agent::LoginReponse>(GetArenaNoVirtual());
    rsplogin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.rspLogin)
  return rsplogin_;
}
inline void AgentPdu::set_allocated_rsplogin(::Agent::LoginReponse* rsplogin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rsplogin_;
  }
  if (rsplogin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rsplogin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsplogin, submessage_arena);
    }
    
  } else {
    
  }
  rsplogin_ = rsplogin;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.rspLogin)
}

// .Agent.HeartBeatRequest reqHb = 4;
inline bool AgentPdu::has_reqhb() const {
  return this != internal_default_instance() && reqhb_ != NULL;
}
inline void AgentPdu::clear_reqhb() {
  if (GetArenaNoVirtual() == NULL && reqhb_ != NULL) {
    delete reqhb_;
  }
  reqhb_ = NULL;
}
inline const ::Agent::HeartBeatRequest& AgentPdu::_internal_reqhb() const {
  return *reqhb_;
}
inline const ::Agent::HeartBeatRequest& AgentPdu::reqhb() const {
  const ::Agent::HeartBeatRequest* p = reqhb_;
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.reqHb)
  return p != NULL ? *p : *reinterpret_cast<const ::Agent::HeartBeatRequest*>(
      &::Agent::_HeartBeatRequest_default_instance_);
}
inline ::Agent::HeartBeatRequest* AgentPdu::release_reqhb() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.reqHb)
  
  ::Agent::HeartBeatRequest* temp = reqhb_;
  reqhb_ = NULL;
  return temp;
}
inline ::Agent::HeartBeatRequest* AgentPdu::mutable_reqhb() {
  
  if (reqhb_ == NULL) {
    auto* p = CreateMaybeMessage<::Agent::HeartBeatRequest>(GetArenaNoVirtual());
    reqhb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.reqHb)
  return reqhb_;
}
inline void AgentPdu::set_allocated_reqhb(::Agent::HeartBeatRequest* reqhb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reqhb_;
  }
  if (reqhb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reqhb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reqhb, submessage_arena);
    }
    
  } else {
    
  }
  reqhb_ = reqhb;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.reqHb)
}

// .Agent.HeartBeatReponse rspHb = 5;
inline bool AgentPdu::has_rsphb() const {
  return this != internal_default_instance() && rsphb_ != NULL;
}
inline void AgentPdu::clear_rsphb() {
  if (GetArenaNoVirtual() == NULL && rsphb_ != NULL) {
    delete rsphb_;
  }
  rsphb_ = NULL;
}
inline const ::Agent::HeartBeatReponse& AgentPdu::_internal_rsphb() const {
  return *rsphb_;
}
inline const ::Agent::HeartBeatReponse& AgentPdu::rsphb() const {
  const ::Agent::HeartBeatReponse* p = rsphb_;
  // @@protoc_insertion_point(field_get:Agent.AgentPdu.rspHb)
  return p != NULL ? *p : *reinterpret_cast<const ::Agent::HeartBeatReponse*>(
      &::Agent::_HeartBeatReponse_default_instance_);
}
inline ::Agent::HeartBeatReponse* AgentPdu::release_rsphb() {
  // @@protoc_insertion_point(field_release:Agent.AgentPdu.rspHb)
  
  ::Agent::HeartBeatReponse* temp = rsphb_;
  rsphb_ = NULL;
  return temp;
}
inline ::Agent::HeartBeatReponse* AgentPdu::mutable_rsphb() {
  
  if (rsphb_ == NULL) {
    auto* p = CreateMaybeMessage<::Agent::HeartBeatReponse>(GetArenaNoVirtual());
    rsphb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Agent.AgentPdu.rspHb)
  return rsphb_;
}
inline void AgentPdu::set_allocated_rsphb(::Agent::HeartBeatReponse* rsphb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rsphb_;
  }
  if (rsphb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rsphb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rsphb, submessage_arena);
    }
    
  } else {
    
  }
  rsphb_ = rsphb;
  // @@protoc_insertion_point(field_set_allocated:Agent.AgentPdu.rspHb)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Agent

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Agent::Errno> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::Errno>() {
  return ::Agent::Errno_descriptor();
}
template <> struct is_proto_enum< ::Agent::Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::Command>() {
  return ::Agent::Command_descriptor();
}
template <> struct is_proto_enum< ::Agent::AppId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::AppId>() {
  return ::Agent::AppId_descriptor();
}
template <> struct is_proto_enum< ::Agent::PackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::PackType>() {
  return ::Agent::PackType_descriptor();
}
template <> struct is_proto_enum< ::Agent::Opcode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::Opcode>() {
  return ::Agent::Opcode_descriptor();
}
template <> struct is_proto_enum< ::Agent::NetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::NetType>() {
  return ::Agent::NetType_descriptor();
}
template <> struct is_proto_enum< ::Agent::NodeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Agent::NodeStatus>() {
  return ::Agent::NodeStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Agent_2eproto
